<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
      Ahmed Hossam
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="The lexical analyzer (lexer) takes a stream of characters and produces a stream of names, keywords, and punctuation marks; it discards white space and comments between the tokens.
Lexical tokens have types in any programming language, example:
ID foo, x, n14 NUM 73, 0, 082 REAL 3.14, 10., 1e9, 0.5 COMMA , NOTEQ != LPAREN ( RPAREN ) Punctuation tokens such as IF, VOID , RETURN constructed from alphabetic characters are called reserved words and, in most languages, cannot be used as identifiers."
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://ahmedhosssam.github.io/posts/tiger_lexical_analysis/" />
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
  integrity="sha384-mll67QQYkNVn4pXYpa9RMfMSX8ZKX9aYJt/0B6SZpHVi6U3HoR10Sn9VD8Kt6p/Z"
  crossorigin="anonymous">


<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
  integrity="sha384-sPj+KE0zA5NNz4YeK7zyrjUpglN46+lDkFjzAxz4w7U+k2e5zZa+f6e7aXpk/EpD"
  crossorigin="anonymous"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
  integrity="sha384-YbW9oBSsy3RWnXnFK4B74XzBToqEhTVQsbT6gPr3V8RibHg0fZq5eFDRauAZW0Xp"
  crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  });"></script>









<link rel="stylesheet" href="https://ahmedhosssam.github.io/css/style.css" />

<link rel="stylesheet" href="https://ahmedhosssam.github.io/style.css" />


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://ahmedhosssam.github.io/img/apple-touch-icon-144-precomposed.png" />
<link rel="shortcut icon" href="https://ahmedhosssam.github.io/img/favicon.png" />


<link href="https://ahmedhosssam.github.io/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://ahmedhosssam.github.io/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://ahmedhosssam.github.io/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://ahmedhosssam.github.io/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://ahmedhosssam.github.io/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://ahmedhosssam.github.io/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="The Tiger Book: 2 Lexical Analysis">
  <meta name="twitter:description" content="The lexical analyzer (lexer) takes a stream of characters and produces a stream of names, keywords, and punctuation marks; it discards white space and comments between the tokens.
Lexical tokens have types in any programming language, example:
ID foo, x, n14 NUM 73, 0, 082 REAL 3.14, 10., 1e9, 0.5 COMMA , NOTEQ != LPAREN ( RPAREN ) Punctuation tokens such as IF, VOID , RETURN constructed from alphabetic characters are called reserved words and, in most languages, cannot be used as identifiers.">



<meta property="og:url" content="https://ahmedhosssam.github.io/posts/tiger_lexical_analysis/">
  <meta property="og:site_name" content="Ahmed Hossam">
  <meta property="og:title" content="The Tiger Book: 2 Lexical Analysis">
  <meta property="og:description" content="The lexical analyzer (lexer) takes a stream of characters and produces a stream of names, keywords, and punctuation marks; it discards white space and comments between the tokens.
Lexical tokens have types in any programming language, example:
ID foo, x, n14 NUM 73, 0, 082 REAL 3.14, 10., 1e9, 0.5 COMMA , NOTEQ != LPAREN ( RPAREN ) Punctuation tokens such as IF, VOID , RETURN constructed from alphabetic characters are called reserved words and, in most languages, cannot be used as identifiers.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-24T12:18:42+03:00">
    <meta property="article:modified_time" content="2025-08-24T12:18:42+03:00">






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="https://ahmedhosssam.github.io/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Ahmed Hossam</span
    >
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href=""></a></li>
        
      
        
          <li><a href="https://ahmedhosssam.github.io/about">About</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href=""></a></li>
      
    
      
        <li><a href="https://ahmedhosssam.github.io/about">About</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <article class="post">
    <h1 class="post-title">The Tiger Book: 2 Lexical Analysis</h1>
    <div class="post-meta">
      
        <time class="post-date">
          2025-08-24
        </time>

        
          
        
      

      


      
    </div>

    

    

    <div class="post-content">
      
      <p>The lexical analyzer (lexer) takes a stream of characters and produces a stream of names, keywords, and punctuation marks; it discards white space and comments between the tokens.</p>
<p>Lexical tokens have types in any programming language, example:</p>
<ul>
<li>ID <code>foo, x, n14</code></li>
<li>NUM <code>73, 0, 082</code></li>
<li>REAL <code>3.14, 10., 1e9, 0.5</code></li>
<li>COMMA <code>,</code></li>
<li>NOTEQ <code>!=</code></li>
<li>LPAREN <code>(</code></li>
<li>RPAREN <code>)</code></li>
</ul>
<p>Punctuation tokens such as <code>IF</code>, <code>VOID</code> , <code>RETURN</code> constructed from alphabetic characters are called <strong>reserved words</strong> and, in most languages, cannot be used as identifiers.</p>
<p><strong>Preprocessor Directives</strong>: The preprocesser operates on the source character stream, producing another character stream, that new character stream is one that is fed to the lexical analyzer.</p>
<p>It is also possible to integrate macro processing with lexical analysis.</p>
<p>Example of preprocessor directives:</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
#define NUMS 5 , 6
</code></pre><p>The goal of preprocessor directives is to include files or code, defining macros, or conditional compilation.</p>
<h2 id="regular-expressions">
  Regular Expressions
  <a href="#regular-expressions" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>To Implement a lexer you can do it in an ad hoc way, but that can be complicated. A simpler (and also the most common) way is to use <strong>finite automata</strong> and <strong>regular expressions</strong>.</p>
<p>Each token type will have its own regex, and to get the next token in the source code, you basically need to run every DFA (which is the implementation of regex in the lexer) and returns the longest match, why the longest?</p>
<p>Because, image if you have a token such as <code>if16</code>, this is an identifier, but it will accept the <code>IF</code> DFA. So we need to find the longest match, which will be the identifier match. For <code>if16</code> the identifier DFA will reterun 4, and <code>IF</code> DFA will return 2, so we will classify the token as an identifier token.</p>
<p>Another Example:
For a token like <code>ifelse</code>, when we pass it through the 3 DFAs <code>IF</code>, <code>ELSE</code>, and identifier, it will result an identifier. Because it&rsquo;s the longest (a token of length 6), not <code>IF</code> followed by <code>ELSE</code>.</p>
<p><strong>Note</strong>: Regular expressions are <em>static</em> and <em>declarative</em>, automata are <em>dynamic</em> and <em>imperative</em>. That&rsquo;s why regular expressions are usually more convenient to specify the lexical structure of programming-language tokens.</p>
<p><strong>Rule Priority</strong>: If two or more rules (regexes) match the same longest length, the first regex wins. This means that the order of writing down the regular expression rules has significance.</p>
<p><strong>Note</strong>: Regexes don&rsquo;t have to be implemented as a DFA, it can be NFA as well, but it will be slower, because it explores multiple possible states at once, which leads to a lot of backtracking, which will take more time.</p>
<h2 id="lex">
  Lex
  <a href="#lex" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>One of the tools that automate the workflow of implementing DFAs for regular expressions is <strong>Lex</strong>.</p>
<p>Lex is a lexical analyzers generator that takes a list of regular expressions (action rules) and generates a fast DFA-based C scanner that matches the longest regex.</p>
<p><strong>Example of using Lex</strong>:</p>
<p>The regex rules are usually being written in a <code>lx.l</code> file (the extension <code>.l</code> is used for lex source files, but other people use <code>.lex</code> also. Both are valid) , and it looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// lx.l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">%%</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello world&#34;</span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;GOODBYE</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>dog.<span style="color:#f92672">*</span>cat <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;A cat and a dog found&#34;</span>);
</span></span><span style="display:flex;"><span>. ;
</span></span><span style="display:flex;"><span><span style="color:#f92672">%%</span>
</span></span></code></pre></div><p>This Lex file has 3 rules:</p>
<ul>
<li><code>&quot;hello world&quot;</code> which searches for the string &ldquo;hello world&rdquo; and prints &ldquo;GOODBYE&rdquo; if it finds it.</li>
<li><code>dog.*cat</code> is a regex that matches the pattern &ldquo;dog, then any number of characters, then a cat&rdquo;, and prints &ldquo;A cat and a dog found&rdquo; if it finds it.</li>
<li>The regex <code>.</code> searches for any character and then just ignores it.</li>
</ul>
<p><strong>Lex</strong> applys the most important rule that we talked about, which is matching the longest regex. Because here maybe someone would say that if we put <code>. ;</code> before <code>dog.*cat</code> the lexer would ignore an input like this: <code>dogxcat</code> because it matches the first regex. But no, our goal is to find the longest match, and here the longest match is the regex <code>dog.*cat</code> because it returns a valid pattern of 7 characters, but <code>.</code> returns 7 consecutive valid patterns of length 1.</p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
            
              <span class="button next">
                <a href="https://ahmedhosssam.github.io/posts/tiger_intro/">
                  <span class="button__text">The Tiger Book: 1 Introduction</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </article>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="https://ahmedhosssam.github.io/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Ahmed Hossam</span
    >
  
</a>

      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span>
        <span><a href="https://github.com/panr/hugo-theme-hello-friend" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
    
  </div>
</footer>





<script type="text/javascript" src="https://ahmedhosssam.github.io/bundle.min.js"></script>


      
    </div>

    
  </body>
</html>
